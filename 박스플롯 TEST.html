<script>
  // --- 고정 X축 순서 ---
  const GRADE_ORDER = ['초급','중급','고급','특급','컨설턴트'];

  // --- 설정 상수 ---
  const EXCEL_SHEET_NAME = "외주용역"; // 시트명
  const ROW_START = 477; // 포함 (엑셀 1-based)
  const ROW_END   = 750; // 포함 (엑셀 1-based)
  const COL_P_IDX = 15;  // P열 = 0-based 15 (분류)
  const COL_U_IDX = 20;  // U열 = 0-based 20 (서비스등급)
  const COL_Z_IDX = 25;  // Z열 = 0-based 25 (서비스단가, Y축으로 고정)

  const els = {
    file: document.getElementById('file'),
    loadDefault: document.getElementById('loadDefault'),
    category: document.getElementById('category'),
    orientation: document.getElementById('orientation'),
    outliers: document.getElementById('outliers'),
    plot: document.getElementById('plot'),
  };

  let state = {
    headers: [],
    rows: [],
    categoryValues: [],
  };

  function unique(arr) {
    return Array.from(new Set(arr.filter(v => v !== undefined && v !== null && String(v).trim() !== '')));
  }

  async function loadWorkbookFromArrayBuffer(ab) {
    const wb = XLSX.read(ab, { type: 'array' });
    const sheetName = wb.Sheets[EXCEL_SHEET_NAME] ? EXCEL_SHEET_NAME : wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    return XLSX.utils.sheet_to_json(ws, { header:1, raw: true, defval: null });
  }

  els.file.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const ab = await f.arrayBuffer();
    const rows = await loadWorkbookFromArrayBuffer(ab);
    ingestRows(rows);
  });

  els.loadDefault.addEventListener('click', async () => {
    try {
      const res = await fetch('data.xlsx');
      if (!res.ok) throw new Error('data.xlsx를 찾을 수 없습니다. 같은 폴더에 위치시켜 주세요.');
      const ab = await res.arrayBuffer();
      const rows = await loadWorkbookFromArrayBuffer(ab);
      ingestRows(rows);
    } catch (err) {
      alert(err.message || err);
    }
  });

  function ingestRows(rows){
    if (!rows || !rows.length) {
      alert('시트가 비어있습니다.');
      return;
    }
    const first = rows[0] || [];
    const headerLike = first.some(v => typeof v === 'string');

    let headerRow = headerLike ? first : [];
    let data = headerLike ? rows.slice(1) : rows.slice();

    const startIdx = ROW_START - 1 - (headerLike ? 1 : 0);
    const endIdx   = ROW_END   - 1 - (headerLike ? 1 : 0);
    const slice = data.filter((_, i) => i >= startIdx && i <= endIdx);

    state.rows = slice;
    state.headers = headerRow.length ? headerRow : generateFallbackHeaders(rows[0]?.length || guessMaxCols(slice));

    const pVals = slice.map(r => r[COL_P_IDX]).filter(v => v !== null && v !== undefined && String(v).trim() !== '');
    state.categoryValues = unique(pVals).sort(naturalCompare);

    populateCategorySelect();
    els.orientation.onchange = draw;
    els.outliers.onchange = draw;

    draw();
  }

  function guessMaxCols(rows){ return Math.max(0, ...rows.map(r => (Array.isArray(r) ? r.length : 0))); }

  function generateFallbackHeaders(n){
    const labels = [];
    for (let i=0;i<n;i++) labels.push(columnLabel(i));
    return labels;
  }

  function columnLabel(idx){
    let s = '', n = idx;
    while (n >= 0) { s = String.fromCharCode((n % 26) + 65) + s; n = Math.floor(n / 26) - 1; }
    return s;
  }

  function naturalCompare(a,b){ return String(a).localeCompare(String(b), 'ko', { numeric: true, sensitivity: 'base' }); }

  function populateCategorySelect(){
    els.category.innerHTML = '';
    const optAll = document.createElement('option');
    optAll.value = '__ALL__';
    optAll.textContent = `전체 (${state.categoryValues.length}개 분류)`;
    els.category.appendChild(optAll);

    state.categoryValues.forEach(v => {
      const o = document.createElement('option');
      o.value = String(v);
      o.textContent = String(v);
      els.category.appendChild(o);
    });

    els.category.value = '__ALL__';
    els.category.onchange = draw;
  }

  // 빈 카테고리용 투명 더미 박스 생성
  function makeEmptyBox(name, anchorVal, orient){
    const t = {
      type: 'box',
      name,
      boxpoints: false,
      hoverinfo: 'skip',
      line: { color: 'rgba(0,0,0,0)' },
      fillcolor: 'rgba(0,0,0,0)',
      marker: { color: 'rgba(0,0,0,0)' },
      opacity: 0.01
    };
    if (orient === 'v') {
      t.y = [anchorVal];
    } else {
      t.x = [anchorVal];
      t.orientation = 'h';
    }
    return t;
  }

  function draw(){
    if (!state.rows.length) { Plotly.purge(els.plot); return; }
    const catSel = els.category.value;
    const orient = els.orientation.value; // 'v' or 'h'
    const showOutliers = els.outliers.value !== 'none';

    const filtered = state.rows.filter(r => {
      const p = r[COL_P_IDX], u = r[COL_U_IDX], y = r[COL_Z_IDX];
      if (p === null || p === undefined || String(p).trim() === '') return false;
      if (u === null || u === undefined || String(u).trim() === '') return false;
      if (y === null || y === undefined || y === '' || !isFinite(+y)) return false;
      return catSel === '__ALL__' || String(p) === catSel;
    });

    // 전체 값(축 앵커값 계산용)
    const allVals = filtered.map(r => +r[COL_Z_IDX]).filter(Number.isFinite);
    if (!allVals.length){
      Plotly.purge(els.plot);
      els.plot.innerHTML = '<div style="padding:12px;color:#9ca3af;">선택한 조건에서 표시할 데이터가 없습니다.</div>';
      return;
    }
    const globalMin = Math.min(...allVals);

    // 서비스등급별 그룹화
    const byGrade = new Map();
    for (const r of filtered){
      const grade = String(r[COL_U_IDX]).trim();
      const val = +r[COL_Z_IDX];
      if (!byGrade.has(grade)) byGrade.set(grade, []);
      byGrade.get(grade).push(val);
    }

    // GRADE_ORDER 기준으로 필수 노출 + 데이터 없으면 더미 박스
    const traces = [];
    for (const g of GRADE_ORDER){
      const arr = (byGrade.get(g) || []).filter(Number.isFinite);
      if (arr.length){
        const hover = (orient === 'v')
          ? `${g}<br>%{y:,.0f}원<extra></extra>`
          : `${g}<br>%{x:,.0f}원<extra></extra>`;
        const t = {
          type: 'box',
          name: g,
          boxpoints: showOutliers ? 'suspectedoutliers' : false,
          jitter: 0.3,
          pointpos: 0,
          hovertemplate: hover
        };
        if (orient === 'v') t.y = arr; else { t.x = arr; t.orientation = 'h'; }
        traces.push(t);
      } else {
        // 빈 등급: 축에 이름만 고정되도록 투명 더미 박스 추가
        traces.push(makeEmptyBox(g, globalMin, orient));
      }
    }

    const titleCat = (catSel === '__ALL__') ? '전체 분류' : `분류: ${catSel}`;
    const metricName = state.headers[COL_Z_IDX] ?? `열 ${columnLabel(COL_Z_IDX)}`;

    const numericAxisCommon = {
      tickformat: ',',
      ticksuffix: '원',
      gridcolor: '#1f2937',
      zerolinecolor: '#1f2937',
      automargin: true,
      title: { text: metricName, standoff: 16 }
    };
    const catAxisCommon = {
      gridcolor: '#1f2937',
      zerolinecolor: '#1f2937',
      automargin: true,
      categoryorder: 'array',
      categoryarray: GRADE_ORDER
    };

    const layout = {
      paper_bgcolor: '#0f172a',
      plot_bgcolor: '#0f172a',
      font: { color: '#e5e7eb' },
      margin: { t: 48, r: 24, b: 72, l: 84 },
      title: `${titleCat} · Y축: ${metricName} (Z열)`,
      showlegend: false
    };

    if (orient === 'v') {
      layout.xaxis = { title: '서비스등급 (U열)', ...catAxisCommon };
      layout.yaxis = numericAxisCommon;
    } else {
      layout.xaxis = numericAxisCommon;
      layout.yaxis = { title: '서비스등급 (U열)', ...catAxisCommon };
    }

    Plotly.react(els.plot, traces, layout, {responsive: true, displaylogo:false});
  }

  (async function tryAutoLoad(){
    try {
      const res = await fetch('data.xlsx', { method: 'HEAD' });
      if (res.ok) {
        const get = await fetch('data.xlsx');
        const ab = await get.arrayBuffer();
        const rows = await loadWorkbookFromArrayBuffer(ab);
        ingestRows(rows);
      }
    } catch (e) { /* 기본 파일이 없으면 무시 */ }
  })();
</script>
